# -*- coding: utf-8 -*-
# this file is released under public domain and you can use without limitations

#########################################################################
## This is a sample controller
## - index is the default action of any application
## - user is required for authentication and authorization
## - download is for downloading files uploaded in the db (does streaming)
#########################################################################

def index():
    response.menu = []
    return dict()

def admin():
    grids = []
    messages = []
    messages.append('Grid')
    profileGrid = SQLFORM.grid(db.profile, fields=(db.profile.fname,db.profile.lname,db.profile.email,db.profile.phone,db.profile.locationfortea,db.profile.dayfortea,db.profile.otherpartyfname,db.profile.otherpartylname,db.profile.otherpartyemail,db.profile.otherpartyphone,db.profile.otherpartyapprove,db.profile.otherpartycomment), create=False,editable=False,deletable=False,onupdate=adminGridUpdate,paginate=20,searchable=True, maxtextlength=1000, exportclasses=dict(tsv=False, xml=False, html=False, json=False, tsv_with_hidden_cols=False, csv_with_hidden_cols=False), details=False,csv=False)
    grids.append(profileGrid)
    return dict(grid=profileGrid, messages=messages)

def adminGridUpdate(form):
    if form.vars.otherpartyapprove == True:
        userMail = mail.send(to=[form.vars.email, form.vars.otherpartyemail], subject='Banner Account Request - Approved', message=form.vars.fname +" " +"Your Banner Account Request has been approved.")
    if form.vars.disapprove == True:
        userMail = mail.send(to=[form.vars.email , form.vars.otherpartyemail], subject='Banner Account Request - Declined', message=form.vars.fname +" " +"Your Banner Account Request has been Declined.")
        
def schedule():
    if request.vars:
        response.menu = []
    return dict()

def processschedule():
    if request.vars:
        response.menu = []
        profile = []
        #profileStr = ",".join(profile)
        profileID = db.profile.insert(fname=request.vars.fname,lname=request.vars.lname, email=request.vars.email,phone=request.vars.phone,locationfortea=request.vars.locationfortea,dayfortea=request.vars.dayfortea,timefortea=request.vars.timefortea,otherpartyfname=request.vars.otherpartyfname,otherpartylname=request.vars.otherpartylname,otherpartyemail=request.vars.otherpartyemail,otherpartyphone=request.vars.otherpartyphone)
        profileEmail = mail.send(to=[request.vars.otherpartyemail],subject='Schedule Event - Pending Other Party Approval',message=('<html>You have a pending request <a href= "https://web.uncfsu.edu/tea/default/otherparty/' + str(profileID) + '">review this request</a></html>'))
    message = "Your request has been emailed to the other party for approval."
    return dict(message=message)


def otherparty():
    response.menu = []
    response.title = "Other Party"
    record = db.profile[request.args[0]]
    return dict(row=record)
    return dict(message=message)

def processotherparty():
    response.menu = []
    depts = []
    den = ['den']
    otherpartyemail=request.vars.otherpartyemail
    if request.vars:
        record = db.profile[request.args[0]]
        #combined_name = record.vars.fname + record.vars.lname
        if request.vars.decision == "approve":
            record.update_record(otherpartyapprove=True, otherpartycomment=request.vars.otherpartycomment)
            statusEmail = mail.send(to=[record.email,record.otherpartyemail], subject='Schedule Event - Approved', message='Thank you for accepting this event. The other party with be notified. Here are the details for your records'"\n\n" +
        "Whos the event with:" + " " + record.fname + "\n \n" +   
        "Where are you having the event: " + " " + record.dayfortea + " " + record.locationfortea + " " + record.timefortea + "\n" +
        "Other parties contact information: " + " " + record.email + " " + record.phone + "\n" +
        "Comments: " + " " + record.otherpartycomment + "\n" +
        "This workorder was automatically generated by the Tolentino and Castro's web application!"
        )
            otherEmail = mail.send(to=[record.email], subject='Schedule Event - Approved', message= record.otherpartyfname +" " +"Your Request has been approved.")
            message= "You have accepted this request. An email will be sent to the corresponding party to inform them of this action."
            #  " " +

        else:
            record.update_record(otherpartyapprove=False, otherpartycomment=request.vars.managercomment)
            statusEmail = mail.send(to=[record.otherpartyemail], subject='Schedule Event - Declined', message=('<html> Your request has been declined!</html>'))
            message = "You have denied this request. An email will be sent to the corresponding party to inform them of this action."
    return dict(message=message,depts=depts)

def user():
    """
    exposes:
    http://..../[app]/default/user/login
    http://..../[app]/default/user/logout
    http://..../[app]/default/user/register
    http://..../[app]/default/user/profile
    http://..../[app]/default/user/retrieve_password
    http://..../[app]/default/user/change_password
    http://..../[app]/default/user/bulk_register
    use @auth.requires_login()
        @auth.requires_membership('group name')
        @auth.requires_permission('read','table name',record_id)
    to decorate functions that need access control
    also notice there is http://..../[app]/appadmin/manage/auth to allow administrator to manage users
    """
    return dict(form=auth())


@cache.action()
def download():
    """
    allows downloading of uploaded files
    http://..../[app]/default/download/[filename]
    """
    return response.download(request, db)


def call():
    """
    exposes services. for example:
    http://..../[app]/default/call/jsonrpc
    decorate with @services.jsonrpc the functions to expose
    supports xml, json, xmlrpc, jsonrpc, amfrpc, rss, csv
    """
    return service()
